const express = require("express");
const router = express.Router();
const getDatabaseConnection = require("../utils/database");
const getDynamicModel = require("../utils/dynamicModel");

function optimizeShiftAssignments(requiredShiftsPerDay, finalPredictions, missingShiftsPerDay, shiftDetails) {
  let updatedPredictions = [...finalPredictions];
  let updatedMissingShifts = JSON.parse(JSON.stringify(missingShiftsPerDay));

  // üîπ Suivi des heures travaill√©es et des shifts accept√©s
  let weeklyHours = {};
  let employeeShifts = {}; // Stocke les shifts accept√©s par employ√©

  // üìå Initialiser les heures travaill√©es et les shifts par employ√©
  updatedPredictions.forEach(pred => {
    const shiftDuration = shiftDetails[pred.shiftId]?.duration || 0;

    if (!weeklyHours[pred.employeeId]) weeklyHours[pred.employeeId] = 0;
    if (!employeeShifts[pred.employeeId]) employeeShifts[pred.employeeId] = [];

    if (pred.status === "accepted") {
      weeklyHours[pred.employeeId] += shiftDuration;
      employeeShifts[pred.employeeId].push({
        selectedDay: pred.selectedDay,
        shiftId: pred.shiftId,
        shiftDuration: shiftDuration,
        predId: pred._id
      });
    }
  });

  // üîπ Fonction pour v√©rifier si un employ√© peut accepter un shift sans d√©passer 40h
  const canAcceptShift = (employeeId, shiftDuration) => {
    return (weeklyHours[employeeId] || 0) + shiftDuration <= 40;
  };

  // üîπ √âtape 1 : Parcourir les shifts manquants et essayer de combler avec des shifts refus√©s
  for (let day in updatedMissingShifts) {
    for (let missingShift of updatedMissingShifts[day]) {
      if (missingShift.missing > 0) {
        let shiftId = missingShift.shiftId;

        // Trouver tous les employ√©s ayant une disponibilit√© refus√©e pour ce shift
        let rejectedCandidates = updatedPredictions.filter(pred =>
          pred.selectedDay === day &&
          pred.shiftId === shiftId &&
          pred.status === "rejected"
        );

        // Trier les candidats en priorit√© par nombre d'heures travaill√©es (favoriser ceux qui ont le moins d'heures)
        rejectedCandidates.sort((a, b) => (weeklyHours[a.employeeId] || 0) - (weeklyHours[b.employeeId] || 0));

        for (let candidate of rejectedCandidates) {
          if (missingShift.missing <= 0) break; // Arr√™ter si le manque est combl√©

          const shiftDuration = shiftDetails[candidate.shiftId]?.duration || 0;

          // üî¥ Si l'employ√© peut accepter directement ce shift sans d√©passer 40h, on l'accepte
          if (canAcceptShift(candidate.employeeId, shiftDuration)) {
            updatedPredictions = updatedPredictions.map(pred =>
              pred._id === candidate._id ? { ...pred, status: "accepted", reason: "Accepted to fill missing shift" } : pred
            );

            weeklyHours[candidate.employeeId] += shiftDuration;
            missingShift.missing -= 1;

            // Ajouter le shift √† la liste des shifts accept√©s
            employeeShifts[candidate.employeeId].push({
              selectedDay: candidate.selectedDay,
              shiftId: candidate.shiftId,
              shiftDuration: shiftDuration,
              predId: candidate._id
            });

          } else {
            // üî¥ Si l'employ√© d√©passe 40h, on cherche un shift √† retirer pour lui permettre de prendre ce shift

            let possibleShiftToRemove = employeeShifts[candidate.employeeId].find(shift =>
              shift.selectedDay !== candidate.selectedDay // On ne doit pas cr√©er de vide dans la m√™me journ√©e
            );

            if (possibleShiftToRemove) {
              // üîπ Trouver un rempla√ßant pour le shift qui va √™tre retir√©
              let replacementCandidate = updatedPredictions.find(pred =>
                pred.selectedDay === possibleShiftToRemove.selectedDay &&
                pred.shiftId === possibleShiftToRemove.shiftId &&
                pred.status === "rejected" &&
                canAcceptShift(pred.employeeId, possibleShiftToRemove.shiftDuration)
              );

              if (replacementCandidate) {
                // ‚úÖ Accepter la dispo du rempla√ßant
                updatedPredictions = updatedPredictions.map(pred =>
                  pred._id === replacementCandidate._id ? { ...pred, status: "accepted", reason: "Accepted as replacement" } : pred
                );

                weeklyHours[replacementCandidate.employeeId] += possibleShiftToRemove.shiftDuration;

                // ‚úÖ Retirer le shift existant pour accepter le nouveau
                updatedPredictions = updatedPredictions.map(pred =>
                  pred._id === possibleShiftToRemove.predId ? { ...pred, status: "rejected", reason: "Removed to optimize schedule" } : pred
                );

                weeklyHours[candidate.employeeId] -= possibleShiftToRemove.shiftDuration;

                // ‚úÖ Accepter maintenant le nouveau shift
                updatedPredictions = updatedPredictions.map(pred =>
                  pred._id === candidate._id ? { ...pred, status: "accepted", reason: "Accepted after shift swap" } : pred
                );

                weeklyHours[candidate.employeeId] += shiftDuration;
                missingShift.missing -= 1;

                // üîπ Mise √† jour des shifts accept√©s
                employeeShifts[candidate.employeeId] = employeeShifts[candidate.employeeId].filter(
                  shift => shift.predId !== possibleShiftToRemove.predId
                );

                employeeShifts[candidate.employeeId].push({
                  selectedDay: candidate.selectedDay,
                  shiftId: candidate.shiftId,
                  shiftDuration: shiftDuration,
                  predId: candidate._id
                });

                employeeShifts[replacementCandidate.employeeId].push({
                  selectedDay: possibleShiftToRemove.selectedDay,
                  shiftId: possibleShiftToRemove.shiftId,
                  shiftDuration: possibleShiftToRemove.shiftDuration,
                  predId: replacementCandidate._id
                });
              }
            }
          }
        }
      }
    }
  }

  // üîπ Mise √† jour des shifts manquants apr√®s optimisation
  let correctedMissingShifts = {};

  Object.entries(requiredShiftsPerDay).forEach(([day, shiftsNeeded]) => {
    Object.entries(shiftsNeeded).forEach(([shiftId, { needed }]) => {
      let acceptedForShift = updatedPredictions.filter(p =>
        p.selectedDay === day && p.shiftId === shiftId && p.status === "accepted"
      ).length;

      let missing = needed - acceptedForShift;

      if (missing > 0) {
        if (!correctedMissingShifts[day]) correctedMissingShifts[day] = [];
        correctedMissingShifts[day].push({
          shiftId: shiftId,
          needed: needed,
          accepted: acceptedForShift,
          missing: missing
        });
      }
    });
  });

  updatedMissingShifts = correctedMissingShifts;

  return { updatedPredictions, updatedMissingShifts };
}





router.post("/predict-shifts", async (req, res) => {
  try {
    const { dsp_code, weekRange, requiredShiftsPerDay, optimization } = req.body;
    if (!dsp_code || !weekRange || !requiredShiftsPerDay) {
      return res.status(500).json({ message: "‚ùå Missing required parameters." });
    }
    const connection = await getDatabaseConnection(dsp_code);
    const Disponibilite = getDynamicModel(connection, "Disponibilite", require("../Disponibiltes-api/models/disponibilite"));
    const Employee = getDynamicModel(connection, "Employee", require("../Employes-api/models/Employee"));
    const Shift = getDynamicModel(connection, "Shift", require("../Shifts-api/models/shift"));
    const TimeCard = getDynamicModel(connection, "TimeCard", require("../TimeCard-api/models/TimeCard"));

    const requestedDates = Object.keys(requiredShiftsPerDay);
    const disponibilites = await Disponibilite.find({ selectedDay: { $in: requestedDates } });

    if (disponibilites.length === 0) {
      return res.status(200).json({ message: "‚ÑπÔ∏è Aucune disponibilit√© trouv√©e pour cette semaine.", predictions: [] });
    }

    // R√©cup√©rer les d√©tails des shifts
    const shiftIds = [...new Set(disponibilites.map((d) => d.shiftId))];
    const shifts = await Shift.find({ _id: { $in: shiftIds } });

    const shiftDetails = {};
    shifts.forEach((shift) => {
      const startTime = parseInt(shift.starttime.split(":")[0], 10) * 60 + parseInt(shift.starttime.split(":")[1], 10);
      const endTime = parseInt(shift.endtime.split(":")[0], 10) * 60 + parseInt(shift.endtime.split(":")[1], 10);
      let duration = (endTime - startTime) / 60;

      // Retirer 30 minutes si le shift dure plus de 5 heures
      if (duration > 5) {
        duration -= 0.5;
      }

      shiftDetails[shift._id] = {
        name: shift.name,
        color: shift.color,
        duration
      };
    });
    // console.log("shiftDetails:", JSON.stringify(shiftDetails, null, 2));


    // R√©cup√©rer les employ√©s concern√©s
    const employeeIds = [...new Set(disponibilites.map((d) => d.employeeId))];
    let employees = await Employee.find({ _id: { $in: employeeIds } });

    const scorePriority = { Fantastic: 1, Great: 2, Fair: 3, Poor: 4, "New DA": 5 };
    employees = employees.sort((a, b) => (scorePriority[a.scoreCard] || 6) - (scorePriority[b.scoreCard] || 6));

    const employeeDetails = Object.fromEntries(employees.map(emp => [emp._id, emp]));



    // R√©cup√©rer la performance des employ√©s sur leurs derniers shifts (max 10)
    const employeePerformance = {}; // Stocke les performances des employ√©s

    for (const employeeId of employeeIds) {
      const lastTimeCards = await TimeCard.find({ employeeId }).sort({ day: -1 }).limit(10);
      let overLimitCount = 0;
      let totalCount = lastTimeCards.length; // Nombre de shifts r√©ellement disponibles

      if (totalCount === 0) {
        // Si l'employ√© n'a aucun shift enregistr√©, on le consid√®re comme performant
        employeePerformance[employeeId] = {
          isLowPerformance: false,
          overrunPercentage: "0.00" // 0% de d√©passement
        };
        continue;
      }

      lastTimeCards.forEach(({ startTime, endTime, CortexDuree }) => {

        if (!startTime || !endTime) {
          return; // Passe √† la prochaine TimeCard
        }
        const start = parseInt(startTime.split(":")[0], 10) * 60 + parseInt(startTime.split(":")[1], 10);
        const end = parseInt(endTime.split(":")[0], 10) * 60 + parseInt(endTime.split(":")[1], 10);
        let workedHours = (end - start) / 60;

        if (workedHours > 5) {
          workedHours -= 0.5; // Retirer 30 min si > 5h
        }

        // D√©finir la limite de performance bas√©e sur CortexDuree
        const cortexLimit = parseFloat(CortexDuree) > 5 ? parseFloat(CortexDuree) + 1 : parseFloat(CortexDuree);

        if (workedHours > cortexLimit) {
          overLimitCount++;
        }
      });

      // Ajustement du seuil en fonction du nombre de shifts disponibles
      const performanceThreshold = totalCount >= 10 ? 0.6 : 0.4; // 60% si 10 shifts, 40% si moins
      const overrunPercentage = ((overLimitCount / totalCount) * 100).toFixed(2); // Stocke le % de d√©passement

      // L'employ√© est consid√©r√© comme moins performant s'il d√©passe la limite trop souvent
      employeePerformance[employeeId] = {
        isLowPerformance: (overLimitCount / totalCount) > performanceThreshold,
        overrunPercentage: overrunPercentage
      };
    }


    // R√©cup√©rer les heures travaill√©es la semaine en cours
    const timeCardsCurrentWeek = await TimeCard.find({
      day: { $gte: weekRange.start, $lte: weekRange.end },
      employeeId: { $in: employeeIds }
    });

    const hoursWorkedCurrentWeek = {};
    const shiftsAssignedCurrentWeek = {}; // Compteur des shifts assign√©s par employ√©

    timeCardsCurrentWeek.forEach(({ employeeId, startTime, endTime }) => {
      const start = parseInt(startTime.split(":")[0], 10) * 60 + parseInt(startTime.split(":")[1], 10);
      const end = parseInt(endTime.split(":")[0], 10) * 60 + parseInt(endTime.split(":")[1], 10);
      let workedHours = (end - start) / 60;

      if (workedHours > 5) {
        workedHours -= 0.5; // Retirer 30 min si le shift d√©passe 5h
      }

      hoursWorkedCurrentWeek[employeeId] = (hoursWorkedCurrentWeek[employeeId] || 0) + workedHours;
      shiftsAssignedCurrentWeek[employeeId] = (shiftsAssignedCurrentWeek[employeeId] || 0) + 1;
    });

    // Traitement des disponibilit√©s et attribution des shifts
    let finalPredictions = [];
    let shiftsAcceptedPerEmployee = {}; // Stocke le nombre de shifts accept√©s par employ√©
    let missingShiftsPerDay = {}; // Stocke les jours avec un manque d'employ√©s
    let temporarilyRejected = {}; // Stocker les refus temporaires



    Object.entries(requiredShiftsPerDay).forEach(([day, shiftsNeeded]) => {
      let dailyDisponibilites = disponibilites.filter((d) => d.selectedDay === day);
      // Trier les disponibilit√©s par priorit√© de score
      dailyDisponibilites.sort((a, b) => (scorePriority[employeeDetails[a.employeeId]?.scoreCard] || 6) - (scorePriority[employeeDetails[b.employeeId]?.scoreCard] || 6));
      Object.entries(shiftsNeeded).forEach(([shiftId, { needed, extra }]) => {
        let maxEmployees = needed + extra;
        let accepted = 0;

        dailyDisponibilites.forEach((dispo) => {
          if (dispo.shiftId !== shiftId) return;

          const employee = employeeDetails[dispo.employeeId];
          const shiftDuration = shiftDetails[shiftId]?.duration || 0;
          const totalHoursIfAccepted = (hoursWorkedCurrentWeek[dispo.employeeId] || 0) + shiftDuration;
          const totalShiftsIfAccepted = (shiftsAssignedCurrentWeek[dispo.employeeId] || 0) + 1;



          // V√©rifier si l'employ√© a une performance faible et rejeter imm√©diatement ses disponibilit√©s
          if (employeePerformance[dispo.employeeId]?.isLowPerformance === true) {
            finalPredictions.push({
              ...dispo.toObject(),
              status: "rejected",
              reason: `Low performance: ${employeePerformance[dispo.employeeId].overrunPercentage}% exceeded estimated time (Cortex Duree)`
            });
            return;
          }

          if (totalHoursIfAccepted > 40) {
            finalPredictions.push({
              ...dispo.toObject(),
              status: "rejected",
              reason: "Maximum weekly hours exceeded"
            });
            return;
          }

          if (totalShiftsIfAccepted > 5) {
            finalPredictions.push({
              ...dispo.toObject(),
              status: "rejected",
              reason: "Maximum weekly shifts exceeded"
            });
            return;
          }

          if (accepted < maxEmployees) {
            finalPredictions.push({
              ...dispo.toObject(),
              status: "accepted",
              hoursWorked: hoursWorkedCurrentWeek[dispo.employeeId] || 0, // Ajouter les heures travaill√©es
              shiftDuration: shiftDetails[shiftId]?.duration || 0 // Ajouter la dur√©e du shift
            });

            // Mettre √† jour les heures travaill√©es
            hoursWorkedCurrentWeek[dispo.employeeId] = totalHoursIfAccepted;
            shiftsAssignedCurrentWeek[dispo.employeeId] = totalShiftsIfAccepted;
            accepted++;
          } else {
            finalPredictions.push({
              ...dispo.toObject(),
              status: "rejected",
              reason: "Shift limit reached",
              hoursWorked: hoursWorkedCurrentWeek[dispo.employeeId] || 0, // Ajouter les heures travaill√©es
              shiftDuration: shiftDetails[shiftId]?.duration || 0 // Ajouter la dur√©e du shift
            });
          }
        });

        // üîç V√©rification du manque de personnel pour ce shift
        let acceptedForShift = finalPredictions.filter(p => p.selectedDay === day && p.shiftId === shiftId && p.status === "accepted").length;
        let missing = needed - acceptedForShift; // Calcul du manque

        if (missing > 0) {
          if (!missingShiftsPerDay[day]) {
            missingShiftsPerDay[day] = [];
          }
          missingShiftsPerDay[day].push({
            shiftId: shiftId,
            needed: needed, // Besoin initial
            accepted: acceptedForShift, // Nombre r√©ellement accept√©
            missing: missing // Manque r√©el
          });
        }

      });
    }

    );

    // üîπ Stocker les disponibilit√©s refus√©es
    const rejectedDisponibilities = {};

    finalPredictions.forEach((prediction) => {
      if (prediction.status === "rejected") {
        if (!rejectedDisponibilities[prediction.selectedDay]) {
          rejectedDisponibilities[prediction.selectedDay] = [];
        }
        rejectedDisponibilities[prediction.selectedDay].push(prediction);
      }
    });



    if (optimization) {
      const optimizedResults = optimizeShiftAssignments(
        requiredShiftsPerDay,
        finalPredictions,
        missingShiftsPerDay,
        shiftDetails // Passer shiftDetails √† la fonction d'optimisation
      );
      finalPredictions = optimizedResults.updatedPredictions;
      missingShiftsPerDay = optimizedResults.updatedMissingShifts;

    }
    res.status(200).json({
      message: "Predictions generated",
      predictions: finalPredictions,
      missingShifts: missingShiftsPerDay
    });


  }

  catch (error) {
    res.status(500).json({ message: "Internal server error", error: error.message });
  }

});

module.exports = router;

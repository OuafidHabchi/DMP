const express = require('express');
const mongoose = require('mongoose');
const { jsPDF } = require('jspdf');
require('jspdf-autotable');
const fs = require('fs');
const path = require('path');
// const trainingSchema = require('../../training-api/models/trainingSchema');
// const Training = mongoose.models.Training || mongoose.model('Training', trainingSchema);
const router = express.Router();
const dbMiddleware = require('../../utils/middleware');

// Middleware pour sp√©cifier le mod√®le n√©cessaire
router.use((req, res, next) => {
  req.requiredModels = ['Training'];
  next();
});












// Assurez-vous que le r√©pertoire "downloads" existe
const downloadsDir = path.join(__dirname, 'downloads');
if (!fs.existsSync(downloadsDir)) {
  fs.mkdirSync(downloadsDir);
}

// Route 1: G√©n√©rer un rapport d'inventaire en PDF
router.post('/generate-pdf', async (req, res) => {
  try {
    const { vehicles = [], phones = [], batteries = [], userName = 'Unknown User', date } = req.body;

    const doc = new jsPDF();
    const fileName = `Inventory_${date}.pdf`;

    // Titre principal
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.text('Inventory Report', 10, 20);

    // Informations g√©n√©rales
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    // Section v√©hicules
    const vehiclesStartY = 45;
    doc.setFontSize(16);
    doc.text('Vehicles', 10, vehiclesStartY);

    if (vehicles.length > 0) {
      doc.autoTable({
        startY: vehiclesStartY + 5,
        head: [['Name', 'Key', 'FuelCard', 'Documents', 'Cable', 'Status']],
        body: vehicles.map((v) => [
          v.name,
          v.key ? 'Yes' : 'No',
          v.FuelCard ? 'Yes' : 'No',
          v.Documents ? 'Yes' : 'No',
          v.cable ? 'Yes' : 'No',
          v.status || 'N/A',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            ((col >= 1 && col <= 4) && rowData[col] === 'No') ||
            (col === 5 && rowData[5].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No vehicles available.', 10, vehiclesStartY + 10);
    }

    // Section t√©l√©phones
    const phonesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : vehiclesStartY + 20;
    doc.setFontSize(16);
    doc.text('Phones', 10, phonesStartY);

    if (phones.length > 0) {
      doc.autoTable({
        startY: phonesStartY + 5,
        head: [['Name', 'Exists', 'Status', 'Comment']],
        body: phones.map((p) => [
          p.name,
          p.exists ? 'Yes' : 'No',
          p.status || 'N/A',
          p.comment || 'No comment',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            (col === 1 && rowData[1] === 'No') ||
            (col === 2 && rowData[2].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No phones available.', 10, phonesStartY + 10);
    }

    // Section batteries
    const batteriesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : phonesStartY + 20;
    doc.setFontSize(16);
    doc.text('Batteries', 10, batteriesStartY);

    if (batteries.length > 0) {
      doc.autoTable({
        startY: batteriesStartY + 5,
        head: [['Name', 'Exists', 'Status', 'Comment']],
        body: batteries.map((b) => [
          b.name,
          b.exists ? 'Yes' : 'No',
          b.status || 'N/A',
          b.comment || 'No comment',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            (col === 1 && rowData[1] === 'No') ||
            (col === 2 && rowData[2].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No batteries available.', 10, batteriesStartY + 10);
    }

    // Sauvegarde du PDF
    const pdfPath = path.join(downloadsDir, fileName);
    fs.writeFileSync(pdfPath, doc.output());

    // Envoi du fichier au client
    res.download(pdfPath, fileName, (err) => {
      if (err) {
        console.error('Error sending PDF:', err);
        res.status(500).send('Error downloading PDF.');
      }
      fs.unlink(pdfPath, (unlinkErr) => {
        if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).send('Error generating PDF.');
  }
});


// Appliquer `dbMiddleware` dynamiquement sur les routes shifts
router.use(dbMiddleware);




// üîÅ REMPLACE TOUTE TA ROUTE /timecard-pdf PAR CE BLOC
router.post('/timecard-pdf', async (req, res) => {
  const { jsPDF } = require('jspdf');
  require('jspdf-autotable');
  const fs = require('fs');
  const os = require('os');
  const path = require('path');

  // util: #RRGGBB -> [r,g,b]
  const hexToRgbArray = (hex = '') => {
    const m = String(hex).trim().match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
    return m ? [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)] : [0, 25, 51];
  };

  try {
    const {
      rows = [],
      timeCards = [],
      employees = {},
      vans = {},
      shifts = {},
      disponibilities = {},
      date = 'Unknown Date',
      userName = 'Unknown User',
    } = req.body;

    // Utils
    const getName = (id) => {
      if (!id) return '';
      const e = employees?.[String(id)];
      return e ? `${e.name || ''} ${e.familyName || ''}`.trim() : '';
    };
    const safe = (v, fallback = 'N/A') => (v ? v : fallback);

    // Si le front a d√©j√† envoy√© rows enrichies, on s'en sert, sinon on retombe sur timeCards
    const source = rows.length ? rows : timeCards;

    // R√©solution robuste helper/replacement pour √©viter les inversions et doublons
    const resolveReplacement = (primaryEmployeeId) => {
      const d = disponibilities?.[primaryEmployeeId];
      const partnerType = (d?.partnerType || '');
      const partnerEmployeeId = (d?.partnerEmployeeId || ''); // c√¥t√© back: id de la personne REMPLAC√âE

      let effectiveDriverId = primaryEmployeeId; // par d√©faut: c'est le planifi√© qui a travaill√©
      let replacedEmployeeId = '';

      if (partnerType === 'replacement') {
        // partnerEmployeeId est la personne REMPLAC√âE
        if (partnerEmployeeId && String(partnerEmployeeId) !== String(primaryEmployeeId)) {
          effectiveDriverId = primaryEmployeeId;
          replacedEmployeeId = partnerEmployeeId;
        } else if (partnerEmployeeId && String(partnerEmployeeId) === String(primaryEmployeeId)) {
          // cas pathologique: on tente de trouver un enregistrement "miroir" o√π l'employ√© effectif appara√Æt
          const mirror = Object.values(disponibilities || {}).find(
            (x) =>
              x.partnerType === 'replacement' &&
              String(x.partnerEmployeeId) === String(primaryEmployeeId) &&
              String(x.employeeId) !== String(primaryEmployeeId)
          );
          if (mirror) {
            effectiveDriverId = String(mirror.employeeId);
            replacedEmployeeId = primaryEmployeeId;
          } else {
            // fallback
            effectiveDriverId = primaryEmployeeId;
            replacedEmployeeId = '';
          }
        }
      }

      return { partnerType, partnerEmployeeId, effectiveDriverId, replacedEmployeeId };
    };

    const tableRows = source.map((r) => {
      // Champs primaires (toujours dispo)
      const primaryEmployeeId = r.primaryEmployeeId || r.employeeId;
      const primaryEmployeeName = r.primaryEmployeeName || getName(primaryEmployeeId);

      // Si le front a d√©j√† calcul√©, on reprend; sinon on r√©sout c√¥t√© back
      const partnerType = r.partnerType || '';
      const partnerEmployeeId = r.partnerEmployeeId || '';
      const fromBack = resolveReplacement(primaryEmployeeId);

      const effectiveDriverId = r.effectiveDriverId || fromBack.effectiveDriverId;
      const replacedEmployeeId =
        r.replacedEmployeeId ||
        (partnerType === 'replacement' ? (partnerEmployeeId || fromBack.replacedEmployeeId) : '');

      const effectiveDriverName = r.effectiveDriverName || getName(effectiveDriverId);
      const replacedEmployeeName = getName(replacedEmployeeId);
      const partnerName = r.partnerName || getName(partnerEmployeeId);

      // Emp√™cher doublon m√™me nom (si bug amont)
      const safeReplacedEmployeeId =
        replacedEmployeeId && String(replacedEmployeeId) !== String(effectiveDriverId)
          ? replacedEmployeeId
          : '';
      const safeReplacedEmployeeName = safeReplacedEmployeeId ? replacedEmployeeName : '';

      // Texte "Additional Info"
      let additionalInfo = '';
      if (partnerType === 'helper' && partnerName) {
        additionalInfo = `Helper: ${partnerName}`;
      } else if (partnerType === 'replacement' && safeReplacedEmployeeName) {
        additionalInfo = `Replaces: ${safeReplacedEmployeeName}`;
      }

      // Van
      const vanNumber = r.vanNumber
        ? r.vanNumber
        : (r.vanId && vans?.[r.vanId]?.vehicleNumber)
          ? vans[r.vanId].vehicleNumber
          : 'N/A';

      // Shift / color
      const shiftId = r.shiftId || (disponibilities?.[primaryEmployeeId]?.shiftId || null);
      const shiftObj = shiftId ? shifts[shiftId] : null;

      return {
        driverName: safe(effectiveDriverName, 'Unknown'),
        vanNumber: safe(vanNumber),
        startTime: safe(r.startTime),
        lastDelivery: safe(r.lastDelivery),
        endTime: safe(r.endTime),
        fuelCardName: safe(r.fuelCardName),
        tel: safe(r.tel),
        powerbank: safe(r.powerbank),
        refueled: Boolean(r.refueled),
        comment: r.comment || 'No comment',
        additionalInfo,           // affich√© en derni√®re colonne
        shiftColor: shiftObj?.color || null,
      };
    });

    const doc = new jsPDF();
    const safeDate = String(date).replace(/[^\w\-]+/g, '_');
    const fileName = `TimeCard_${safeDate}.pdf`;

    // Header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.text('TimeCard Report', 10, 20);

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    // Shift legend
    let legendY = 45;
    const legendX = 10;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Shift Legend:', legendX, legendY);
    legendY += 6;

    Object.entries(shifts).forEach(([sid, so]) => {
      const { name, starttime, endtime, color } = so;
      if (color) {
        const rgb = hexToRgbArray(color);
        doc.setFillColor(...rgb);
        doc.circle(legendX + 3, legendY - 2, 2.5, 'F');
      }
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.text(`${name} (${starttime} - ${endtime})`, legendX + 10, legendY);
      legendY += 8;
    });

    const tableStartY = legendY + 5;

    // Main table
    doc.autoTable({
      startY: tableStartY,
      head: [[
        'Employee',
        'Van',
        'Start',
        'Last',
        'End',
        'Fuel Card',
        'TEL',
        'Battery',
        'Refuel',
        'Comment',
        'Additional Info',
      ]],
      body: tableRows.map(tr => ([
        tr.driverName,
        tr.vanNumber,
        tr.startTime,
        tr.lastDelivery,
        tr.endTime,
        tr.fuelCardName,
        tr.tel,
        tr.powerbank,
        tr.refueled ? 'Yes' : 'No',   // ‚ûï AJOUT (ou 'Yes'/'No')
        tr.comment,
        tr.additionalInfo || '',
      ])),
      styles: {
        font: 'helvetica',
        fontSize: 9,
        cellPadding: 3,
        textColor: [255, 255, 255],
      },
      headStyles: { fillColor: [0, 25, 51], textColor: [255, 255, 255] },
      didParseCell(data) {
        if (data.section === 'body' && typeof data.row.index === 'number') {
          const tr = tableRows[data.row.index];
          if (tr.shiftColor) {
            const rgb = hexToRgbArray(tr.shiftColor);
            data.cell.styles.fillColor = rgb;
          }
        }
      }
    });

    // (Optionnel) si ces helpers existent chez toi
    if (typeof getTrainingDaysForDate === 'function' && typeof generateTrainingDaysDetailTable === 'function') {
      const dayRows = await getTrainingDaysForDate(req, date);
      generateTrainingDaysDetailTable(doc, dayRows, employees, (doc.lastAutoTable?.finalY || tableStartY) + 10);
    }

    const out = doc.output('arraybuffer');
    const tmpPath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tmpPath, Buffer.from(out));

    res.download(tmpPath, fileName, (err) => {
      if (err) {
        console.error('Error sending PDF:', err);
        if (!res.headersSent) res.status(500).send('Error downloading PDF.');
      }
      fs.unlink(tmpPath, (unlinkErr) => {
        if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
      });
    });

  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).send('Error generating PDF.');
  }
});






/**
 * R√©cup√®re tous les jours de training cr√©√©s √† une date sp√©cifique
 * @param {string} dateString - Format "YYYY-MM-DD"
 * @returns {Promise<Array>} Liste des day[] de training pour ce jour-l√†
 */


async function getTrainingDaysForDate(req, dateString) {
  const Training = req.connection.models.Training;
  const allTrainings = await Training.find({}).lean();

  const targetDate = new Date(dateString).toISOString().slice(0, 10); // Format YYYY-MM-DD
  const results = [];

  allTrainings.forEach(training => {
    const fullName = training.fullName;
    const days = training.days || [];

    days.forEach(day => {
      try {
        const createdAt = new Date(parseInt(day._id.toString().substring(0, 8), 16) * 1000);
        const dayDate = createdAt.toISOString().slice(0, 10);

        if (dayDate !== targetDate) return; // ‚õî Ignorer les autres jours

        results.push({
          fullName,
          dayIndex: day.dayIndex,
          startAt: day.times?.startAt || 'N/A',
          breaks: Array.isArray(day.times?.breaks) ? day.times.breaks : [],
          endAt: day.times?.endAt || 'N/A',
          result: day.result || 'unset',
        });
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur parsing ObjectId: ${err.message}`);
      }
    });
  });
  return results;
}




function generateTrainingDaysDetailTable(doc, dayRows = [], employees = {}, startY = 10) {
  if (!Array.isArray(dayRows) || dayRows.length === 0) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.text('No training day data for this date.', 10, startY);
    return;
  }

  const tableData = dayRows.map(row => {

    const break1 = row.breaks[0]
      ? `${row.breaks[0].startAt} - ${row.breaks[0].endAt}`
      : 'None';

    return [
      row.fullName || 'N/A',
      row.dayIndex,
      row.startAt || 'N/A',
      break1,
      row.endAt || 'N/A',
      row.result || 'unset',
    ];
  });

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Training Details (Selected Date)', 10, startY);

  doc.autoTable({
    startY: startY + 6,
    head: [['Candidate', 'Day #', 'Start', 'Break', 'End', 'Result']],
    body: tableData,
    styles: {
      font: 'helvetica',
      fontSize: 9,
      cellPadding: 3,
      textColor: [255, 255, 255],
    },
    headStyles: { fillColor: [51, 51, 51], textColor: [255, 255, 255] },
    alternateRowStyles: { fillColor: [230, 230, 230], textColor: [0, 0, 0] },
  });
}




// üîÅ ROUTE COMPL√àTE (avec tri par Wave - string)
router.post('/cortex-pdf', async (req, res) => {
  const { jsPDF } = require("jspdf");
  require("jspdf-autotable");
  const fs = require("fs");
  const os = require("os");
  const path = require("path");

  try {
    const {
      rows = [],         // { employeeId, driverName?, cortexDuration, cortexEndTime, staging, wave }
      employees = {},    // map id -> employ√©
      date = "Unknown Date",
      userName = "Unknown User",
    } = req.body;

    // Utils
    const getName = (id) => {
      if (!id) return "";
      const e = employees?.[String(id)];
      return e ? `${e.name || ""} ${e.familyName || ""}`.trim() : "";
    };
    const safe = (v, fallback = "N/A") => (v ? v : fallback);

    // üîΩ TRI par Wave (string) ‚Äî vides en bas, comparaison "naturelle"
    const sortedRows = [...rows].sort((a, b) => {
      const wa = String(a.wave || "").trim();
      const wb = String(b.wave || "").trim();
      if (!wa && !wb) return 0;
      if (!wa) return 1;
      if (!wb) return -1;
      return wa.localeCompare(wb, undefined, { numeric: true, sensitivity: "base" });
    });

    // TableRows (chaque timeCard = une ligne)
    const tableRows = sortedRows.map((r) => ({
      driverName: r.driverName || safe(getName(r.employeeId), "Unknown"),
      cortexDuration: safe(r.cortexDuration),
      cortexEndTime: safe(r.cortexEndTime),
      staging: safe(r.staging),
      wave: safe(r.wave, ""),
    }));

    const doc = new jsPDF();
    const safeDate = String(date).replace(/[^\w\-]+/g, "_");
    const fileName = `RoutesDetails_${safeDate}.pdf`;

    // Header
    doc.setFont("helvetica", "bold");
    doc.setFontSize(20);
    doc.text("Routes Details Report", 10, 20);

    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    // Table (header bleu #001933, lignes claires)
    doc.autoTable({
      startY: 50,
      head: [["Driver", "Cortex Duration", "Cortex End Time", "Staging", "Wave"]],
      body: tableRows.map((tr) => [
        tr.driverName,
        tr.cortexDuration,
        tr.cortexEndTime,
        tr.staging,
        tr.wave,
      ]),
      styles: {
        font: "helvetica",
        fontSize: 9,
        cellPadding: 3,
        textColor: [0, 0, 0],                 // texte noir
      },
      headStyles: { fillColor: [0, 25, 51], textColor: [255, 255, 255] }, // bleu #001933
      bodyStyles: { fillColor: [255, 255, 255] },                         // blanc
      alternateRowStyles: { fillColor: [242, 242, 242] },                 // gris clair
    });

    // G√©n√©ration temporaire
    const out = doc.output("arraybuffer");
    const tmpPath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tmpPath, Buffer.from(out));

    res.download(tmpPath, fileName, (err) => {
      if (err) {
        console.error("Error sending Routes Details PDF:", err);
        if (!res.headersSent) res.status(500).send("Error downloading PDF.");
      }
      fs.unlink(tmpPath, (unlinkErr) => {
        if (unlinkErr) console.error("Error deleting Routes Details PDF:", unlinkErr);
      });
    });
  } catch (error) {
    console.error("Error generating Routes Details PDF:", error);
    res.status(500).send("Error generating Routes Details PDF.");
  }
});





module.exports = router;

const express = require('express');
const mongoose = require('mongoose');
const { jsPDF } = require('jspdf');
require('jspdf-autotable');
const fs = require('fs');
const path = require('path');
// const trainingSchema = require('../../training-api/models/trainingSchema');
// const Training = mongoose.models.Training || mongoose.model('Training', trainingSchema);
const router = express.Router();
const dbMiddleware = require('../../utils/middleware');

// Middleware pour sp√©cifier le mod√®le n√©cessaire
router.use((req, res, next) => {
  req.requiredModels = ['Training'];
  next();
});












// Assurez-vous que le r√©pertoire "downloads" existe
const downloadsDir = path.join(__dirname, 'downloads');
if (!fs.existsSync(downloadsDir)) {
  fs.mkdirSync(downloadsDir);
}

// Route 1: G√©n√©rer un rapport d'inventaire en PDF
router.post('/generate-pdf', async (req, res) => {
  try {
    const { vehicles = [], phones = [], batteries = [], userName = 'Unknown User', date } = req.body;

    const doc = new jsPDF();
    const fileName = `Inventory_${date}.pdf`;

    // Titre principal
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.text('Inventory Report', 10, 20);

    // Informations g√©n√©rales
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    // Section v√©hicules
    const vehiclesStartY = 45;
    doc.setFontSize(16);
    doc.text('Vehicles', 10, vehiclesStartY);

    if (vehicles.length > 0) {
      doc.autoTable({
        startY: vehiclesStartY + 5,
        head: [['Name', 'Key', 'FuelCard', 'Documents', 'Cable', 'Status']],
        body: vehicles.map((v) => [
          v.name,
          v.key ? 'Yes' : 'No',
          v.FuelCard ? 'Yes' : 'No',
          v.Documents ? 'Yes' : 'No',
          v.cable ? 'Yes' : 'No',
          v.status || 'N/A',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            ((col >= 1 && col <= 4) && rowData[col] === 'No') ||
            (col === 5 && rowData[5].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No vehicles available.', 10, vehiclesStartY + 10);
    }

    // Section t√©l√©phones
    const phonesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : vehiclesStartY + 20;
    doc.setFontSize(16);
    doc.text('Phones', 10, phonesStartY);

    if (phones.length > 0) {
      doc.autoTable({
        startY: phonesStartY + 5,
        head: [['Name', 'Exists', 'Status', 'Comment']],
        body: phones.map((p) => [
          p.name,
          p.exists ? 'Yes' : 'No',
          p.status || 'N/A',
          p.comment || 'No comment',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            (col === 1 && rowData[1] === 'No') ||
            (col === 2 && rowData[2].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No phones available.', 10, phonesStartY + 10);
    }

    // Section batteries
    const batteriesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : phonesStartY + 20;
    doc.setFontSize(16);
    doc.text('Batteries', 10, batteriesStartY);

    if (batteries.length > 0) {
      doc.autoTable({
        startY: batteriesStartY + 5,
        head: [['Name', 'Exists', 'Status', 'Comment']],
        body: batteries.map((b) => [
          b.name,
          b.exists ? 'Yes' : 'No',
          b.status || 'N/A',
          b.comment || 'No comment',
        ]),
        didParseCell: function (data) {
          const col = data.column.index;
          const rowData = data.row.raw;

          if (
            (col === 1 && rowData[1] === 'No') ||
            (col === 2 && rowData[2].toLowerCase() === 'missing')
          ) {
            data.cell.styles.textColor = [255, 0, 0];
          }
        }
      });
    } else {
      doc.text('No batteries available.', 10, batteriesStartY + 10);
    }

    // Sauvegarde du PDF
    const pdfPath = path.join(downloadsDir, fileName);
    fs.writeFileSync(pdfPath, doc.output());

    // Envoi du fichier au client
    res.download(pdfPath, fileName, (err) => {
      if (err) {
        console.error('Error sending PDF:', err);
        res.status(500).send('Error downloading PDF.');
      }
      fs.unlink(pdfPath, (unlinkErr) => {
        if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
      });
    });
  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).send('Error generating PDF.');
  }
});


// Appliquer `dbMiddleware` dynamiquement sur les routes shifts
router.use(dbMiddleware);




// üîÅ REMPLACE TOUTE TA ROUTE /timecard-pdf PAR CE BLOC
router.post('/timecard-pdf', async (req, res) => {
  const { jsPDF } = require('jspdf');
  require('jspdf-autotable');
  const fs = require('fs');
  const os = require('os');
  const path = require('path');

  // util: #RRGGBB -> [r,g,b]
  const hexToRgbArray = (hex = '') => {
    const m = String(hex).trim().match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
    return m ? [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16)] : [0, 25, 51];
  };

  try {
    const {
      rows = [],
      timeCards = [],
      employees = {},
      vans = {},
      shifts = {},
      disponibilities = {},
      date = 'Unknown Date',
      userName = 'Unknown User',
    } = req.body;

    // Utils
    const getName = (id) => {
      if (!id) return '';
      const e = employees?.[String(id)];
      return e ? `${e.name || ''} ${e.familyName || ''}`.trim() : '';
    };
    const safe = (v, fallback = 'N/A') => (v ? v : fallback);

    // Si le front a d√©j√† envoy√© rows enrichies, on s'en sert, sinon on retombe sur timeCards
    const source = rows.length ? rows : timeCards;

    // R√©solution robuste helper/replacement pour √©viter les inversions et doublons
    const resolveReplacement = (primaryEmployeeId) => {
      const d = disponibilities?.[primaryEmployeeId];
      const partnerType = (d?.partnerType || '');
      const partnerEmployeeId = (d?.partnerEmployeeId || ''); // c√¥t√© back: id de la personne REMPLAC√âE

      let effectiveDriverId = primaryEmployeeId; // par d√©faut: c'est le planifi√© qui a travaill√©
      let replacedEmployeeId = '';

      if (partnerType === 'replacement') {
        // partnerEmployeeId est la personne REMPLAC√âE
        if (partnerEmployeeId && String(partnerEmployeeId) !== String(primaryEmployeeId)) {
          effectiveDriverId = primaryEmployeeId;
          replacedEmployeeId = partnerEmployeeId;
        } else if (partnerEmployeeId && String(partnerEmployeeId) === String(primaryEmployeeId)) {
          // cas pathologique: on tente de trouver un enregistrement "miroir" o√π l'employ√© effectif appara√Æt
          const mirror = Object.values(disponibilities || {}).find(
            (x) =>
              x.partnerType === 'replacement' &&
              String(x.partnerEmployeeId) === String(primaryEmployeeId) &&
              String(x.employeeId) !== String(primaryEmployeeId)
          );
          if (mirror) {
            effectiveDriverId = String(mirror.employeeId);
            replacedEmployeeId = primaryEmployeeId;
          } else {
            // fallback
            effectiveDriverId = primaryEmployeeId;
            replacedEmployeeId = '';
          }
        }
      }

      return { partnerType, partnerEmployeeId, effectiveDriverId, replacedEmployeeId };
    };

    const tableRows = source.map((r) => {
      // Champs primaires (toujours dispo)
      const primaryEmployeeId = r.primaryEmployeeId || r.employeeId;
      const primaryEmployeeName = r.primaryEmployeeName || getName(primaryEmployeeId);

      // Si le front a d√©j√† calcul√©, on reprend; sinon on r√©sout c√¥t√© back
      const partnerType = r.partnerType || '';
      const partnerEmployeeId = r.partnerEmployeeId || '';
      const fromBack = resolveReplacement(primaryEmployeeId);

      const effectiveDriverId = r.effectiveDriverId || fromBack.effectiveDriverId;
      const replacedEmployeeId =
        r.replacedEmployeeId ||
        (partnerType === 'replacement' ? (partnerEmployeeId || fromBack.replacedEmployeeId) : '');

      const effectiveDriverName = r.effectiveDriverName || getName(effectiveDriverId);
      const replacedEmployeeName = getName(replacedEmployeeId);
      const partnerName = r.partnerName || getName(partnerEmployeeId);

      // Emp√™cher doublon m√™me nom (si bug amont)
      const safeReplacedEmployeeId =
        replacedEmployeeId && String(replacedEmployeeId) !== String(effectiveDriverId)
          ? replacedEmployeeId
          : '';
      const safeReplacedEmployeeName = safeReplacedEmployeeId ? replacedEmployeeName : '';

      // Texte "Additional Info"
      let additionalInfo = '';
      if (partnerType === 'helper' && partnerName) {
        additionalInfo = `Helper: ${partnerName}`;
      } else if (partnerType === 'replacement' && safeReplacedEmployeeName) {
        additionalInfo = `Replaces: ${safeReplacedEmployeeName}`;
      }

      // Van
      const vanNumber = r.vanNumber
        ? r.vanNumber
        : (r.vanId && vans?.[r.vanId]?.vehicleNumber)
          ? vans[r.vanId].vehicleNumber
          : 'N/A';

      // Shift / color
      const shiftId = r.shiftId || (disponibilities?.[primaryEmployeeId]?.shiftId || null);
      const shiftObj = shiftId ? shifts[shiftId] : null;

      return {
        driverName: safe(effectiveDriverName, 'Unknown'),
        vanNumber: safe(vanNumber),
        startTime: safe(r.startTime),
        lastDelivery: safe(r.lastDelivery),
        endTime: safe(r.endTime),
        fuelCardName: safe(r.fuelCardName),
        tel: safe(r.tel),
        powerbank: safe(r.powerbank),
        refueled: Boolean(r.refueled),
        comment: r.comment || 'No comment',
        additionalInfo,           // affich√© en derni√®re colonne
        shiftColor: shiftObj?.color || null,
      };
    });

    const doc = new jsPDF();
    const safeDate = String(date).replace(/[^\w\-]+/g, '_');
    const fileName = `TimeCard_${safeDate}.pdf`;

    // Header
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(20);
    doc.text('TimeCard Report', 10, 20);

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    // Shift legend
    let legendY = 45;
    const legendX = 10;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Shift Legend:', legendX, legendY);
    legendY += 6;

    Object.entries(shifts).forEach(([sid, so]) => {
      const { name, starttime, endtime, color } = so;
      if (color) {
        const rgb = hexToRgbArray(color);
        doc.setFillColor(...rgb);
        doc.circle(legendX + 3, legendY - 2, 2.5, 'F');
      }
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(10);
      doc.text(`${name} (${starttime} - ${endtime})`, legendX + 10, legendY);
      legendY += 8;
    });

    const tableStartY = legendY + 5;

    // Main table
    doc.autoTable({
      startY: tableStartY,
      head: [[
        'Employee',
        'Van',
        'Start',
        'Last',
        'End',
        'Fuel Card',
        'TEL',
        'Battery',
        'Refuel',
        'Comment',
        'Additional Info',
      ]],
      body: tableRows.map(tr => ([
        tr.driverName,
        tr.vanNumber,
        tr.startTime,
        tr.lastDelivery,
        tr.endTime,
        tr.fuelCardName,
        tr.tel,
        tr.powerbank,
        tr.refueled ? 'Yes' : 'No',   // ‚ûï AJOUT (ou 'Yes'/'No')
        tr.comment,
        tr.additionalInfo || '',
      ])),
      styles: {
        font: 'helvetica',
        fontSize: 9,
        cellPadding: 2,
        textColor: [255, 255, 255],
        overflow: 'linebreak',
        halign: 'center',
        valign: 'middle',
        lineWidth: 0.1,
        lineColor: '#ffffff',
       
      },
      headStyles: { fillColor: [0, 25, 51], textColor: [255, 255, 255] },
      didParseCell(data) {
        if (data.section === 'body' && typeof data.row.index === 'number') {
          const tr = tableRows[data.row.index];
          if (tr.shiftColor) {
            const rgb = hexToRgbArray(tr.shiftColor);
            data.cell.styles.fillColor = rgb;
          }
        }
      }
    });

    // (Optionnel) si ces helpers existent chez toi
    if (typeof getTrainingDaysForDate === 'function' && typeof generateTrainingDaysDetailTable === 'function') {
      const dayRows = await getTrainingDaysForDate(req, date);
      generateTrainingDaysDetailTable(doc, dayRows, employees, (doc.lastAutoTable?.finalY || tableStartY) + 10);
    }

    const out = doc.output('arraybuffer');
    const tmpPath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tmpPath, Buffer.from(out));

    res.download(tmpPath, fileName, (err) => {
      if (err) {
        console.error('Error sending PDF:', err);
        if (!res.headersSent) res.status(500).send('Error downloading PDF.');
      }
      fs.unlink(tmpPath, (unlinkErr) => {
        if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
      });
    });

  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).send('Error generating PDF.');
  }
});






/**
 * R√©cup√®re tous les jours de training cr√©√©s √† une date sp√©cifique
 * @param {string} dateString - Format "YYYY-MM-DD"
 * @returns {Promise<Array>} Liste des day[] de training pour ce jour-l√†
 */


async function getTrainingDaysForDate(req, dateString) {
  const Training = req.connection.models.Training;
  const allTrainings = await Training.find({}).lean();

  const targetDate = new Date(dateString).toISOString().slice(0, 10); // Format YYYY-MM-DD
  const results = [];

  allTrainings.forEach(training => {
    const fullName = training.fullName;
    const days = training.days || [];

    days.forEach(day => {
      try {
        const createdAt = new Date(parseInt(day._id.toString().substring(0, 8), 16) * 1000);
        const dayDate = createdAt.toISOString().slice(0, 10);

        if (dayDate !== targetDate) return; // ‚õî Ignorer les autres jours

        results.push({
          fullName,
          dayIndex: day.dayIndex,
          startAt: day.times?.startAt || 'N/A',
          breaks: Array.isArray(day.times?.breaks) ? day.times.breaks : [],
          endAt: day.times?.endAt || 'N/A',
          result: day.result || 'unset',
        });
      } catch (err) {
        console.error(`‚ö†Ô∏è Erreur parsing ObjectId: ${err.message}`);
      }
    });
  });
  return results;
}




function generateTrainingDaysDetailTable(doc, dayRows = [], employees = {}, startY = 10) {
  if (!Array.isArray(dayRows) || dayRows.length === 0) {
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.text('No training day data for this date.', 10, startY);
    return;
  }

  const tableData = dayRows.map(row => {

    const break1 = row.breaks[0]
      ? `${row.breaks[0].startAt} - ${row.breaks[0].endAt}`
      : 'None';

    return [
      row.fullName || 'N/A',
      row.dayIndex,
      row.startAt || 'N/A',
      break1,
      row.endAt || 'N/A',
      row.result || 'unset',
    ];
  });

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Training Details (Selected Date)', 10, startY);

  doc.autoTable({
    startY: startY + 6,
    head: [['Candidate', 'Day #', 'Start', 'Break', 'End', 'Result']],
    body: tableData,
    styles: {
      font: 'helvetica',
      fontSize: 9,
      cellPadding: 3,
      textColor: [255, 255, 255],
    },
    headStyles: { fillColor: [51, 51, 51], textColor: [255, 255, 255] },
    alternateRowStyles: { fillColor: [230, 230, 230], textColor: [0, 0, 0] },
  });
}




// üîÅ ROUTE /cortex-pdf ‚Äî autonome (init mod√®les + enrichissement + PDF)
router.post('/cortex-pdf', async (req, res) => {
  const { jsPDF } = require("jspdf");
  require("jspdf-autotable");
  const fs = require("fs");
  const os = require("os");
  const path = require("path");
  const mongoose = require("mongoose");

  // --- helpers locaux (dans la fonction) ---
  const safe = (v, fb = "N/A") => (v !== undefined && v !== null && v !== "" ? v : fb);
  const norm = (s) =>
    String(s || "")
      .normalize("NFKD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/\s+/g, " ")
      .trim()
      .toLowerCase();
  const strId = (x) => {
    try { return (x && x._id) ? String(x._id) : String(x || ""); } catch { return ""; }
  };

  // compile un mod√®le sur la connexion courante √† partir d‚Äôun Schema ou d‚Äôun Model d√©j√† compil√© (r√©utilise .schema/.collection.name)
  const compileOn = (conn, name, def) => {
    if (!def) throw new Error(`Model "${name}" introuvable`);
    if (conn.models[name]) return conn.model(name);
    const schema =
      def instanceof mongoose.Schema ? def :
        def && def.schema ? def.schema :
          null;
    if (!schema) throw new Error(`Model "${name}" sans schema`);
    const collection =
      def && def.collection && def.collection.name ? def.collection.name : undefined;
    return conn.model(name, schema, collection);
  };

  try {
    const {
      rows = [],        // front envoie: driverName?, employeeId?, staging, wave (cortex* ignor√©s ici)
      employees = {},   // optionnel: map id -> { name, familyName }
      date = "Unknown Date",
      userName = "Unknown User",
    } = req.body;

    // --- connexion courante (multi-tenant OK si dbMiddleware a mis req.connection) ---
    const conn = req.connection || mongoose.connection;

    // --- import/compile des mod√®les n√©cessaires (EN LOCAL, DANS LA FONCTION) ---
    //    (si d√©j√† compil√©s sur cette connexion, compileOn les r√©utilise)
    const defs = {};
    try { defs.Employee = require("../../Employes-api/models/Employee"); } catch { }
    try { defs.VanAssignment = require("../../VanAssignmen-api/models/VanAssignment"); } catch { }
    try { defs.Disponibilite = require("../../Disponibiltes-api/models/disponibilite"); } catch { }
    try { defs.Vehicle = require("../../Fleet-api/models/vehicle"); } catch { }

    const Employee = compileOn(conn, "Employee", defs.Employee);
    const VanAssignment = compileOn(conn, "VanAssignment", defs.VanAssignment);
    const Disponibilite = compileOn(conn, "Disponibilite", defs.Disponibilite);
    const Vehicle = compileOn(conn, "Vehicle", defs.Vehicle);

    // --- normalisation date pour matching souple ---
    const raw = String(date || "");
    const decoded = decodeURIComponent(raw);
    const dayStr = new Date(decoded).toDateString();

    // 1) EMPLOYEES ‚Äî index par nom si employeeId manquant
    const employeeMap = { ...(employees || {}) }; // id -> { name, familyName }
    const dbEmployees = await Employee.find({}, { name: 1, familyName: 1 }).lean();
    for (const e of dbEmployees) {
      const id = String(e._id);
      if (!employeeMap[id]) employeeMap[id] = { name: e.name || "", familyName: e.familyName || "" };
    }
    const fullNameOf = (e) => (e ? `${e.name || ""} ${e.familyName || ""}`.trim() : "");
    const nameIndex = {};
    for (const [id, e] of Object.entries(employeeMap)) {
      const n = norm(fullNameOf(e));
      if (n && !nameIndex[n]) nameIndex[n] = id;
    }

    // 2) VAN ASSIGNMENTS du jour ‚Üí employeeId -> van label
    const assignments = await VanAssignment.find(
      { $or: [{ date: { $in: [decoded, dayStr] } }, { selectedDay: { $in: [decoded, dayStr] } }] },
      { employeeId: 1, vanId: 1, vanName: 1, vehicleNumber: 1 }
    ).lean();

    const vanByEmployee = {};
    // charger v√©hicules si vanId existe
    const vanIds = [...new Set(assignments.map(a => a.vanId).filter(Boolean).map(strId))];
    let vehicleMap = {};
    if (vanIds.length) {
      const vehicles = await Vehicle.find({ _id: { $in: vanIds } }).lean();
      vehicleMap = vehicles.reduce((acc, v) => { acc[String(v._id)] = v; return acc; }, {});
    }
    for (const a of assignments) {
      const empId = String(a.employeeId || "");
      let label = a.vehicleNumber || a.vanName || "";
      if (!label && a.vanId && vehicleMap[strId(a.vanId)]) {
        const v = vehicleMap[strId(a.vanId)];
        label = v.vehicleNumber || v.name || v.label || v.plate || "N/A";
      }
      if (empId) vanByEmployee[empId] = label || "";
    }

    // 3) DISPONIBILIT√âS du jour ‚Üí helper/replacement
    const disps = await Disponibilite.find(
      { $or: [{ selectedDay: { $in: [decoded, dayStr] } }, { date: { $in: [decoded, dayStr] } }] },
      { employeeId: 1, partnerType: 1, partnerEmployeeId: 1 }
    ).lean();

    const dispoByEmployee = {};
    for (const d of disps) {
      const empId = String(d.employeeId || "");
      if (!empId) continue;
      dispoByEmployee[empId] = {
        partnerType: d.partnerType || "",
        partnerEmployeeId: d.partnerEmployeeId ? String(d.partnerEmployeeId) : "",
      };
    }
    const resolveAdditionalInfo = (empId) => {
      const d = dispoByEmployee[empId] || {};
      const t = d.partnerType || "";
      const partnerId = d.partnerEmployeeId || "";
      if (!t) return "";
      if (t === "helper") {
        const partnerName = fullNameOf(employeeMap[partnerId] || {});
        return partnerName ? `Helper: ${partnerName}` : "Helper";
      }
      if (t === "replacement") {
        const replacedName = fullNameOf(employeeMap[partnerId] || {});
        return replacedName ? `Replaces: ${replacedName}` : "Replaces: N/A";
      }
      return "";
    };

    // 4) compl√©ter employeeId manquant √† partir du nom
    const withEmployeeId = rows.map((r) => {
      if (r.employeeId) return r;
      const id = nameIndex[norm(r.driverName || "")];
      return id ? { ...r, employeeId: id } : r;
    });

    // 5) tri par Wave (string) (vides en bas)
    const sortedRows = [...withEmployeeId].sort((a, b) => {
      const wa = String(a.wave || "").trim();
      const wb = String(b.wave || "").trim();
      if (!wa && !wb) return 0;
      if (!wa) return 1;
      if (!wb) return -1;
      return wa.localeCompare(wb, undefined, { numeric: true, sensitivity: "base" });
    });

    // 6) construire donn√©es PDF (colonnes demand√©es)
    const tableRows = sortedRows.map((r) => {
      const empId = String(r.employeeId || "");
      const empName =
        r.driverName || fullNameOf(employeeMap[empId] || {}) || "Unknown";
      const vanName = vanByEmployee[empId] || ""; // ‚Üê nom/num du van
      const arriveTime = "";                       // ‚Üê colonne volontairement vide
      const wave = safe(r.wave, "");
      const staging = safe(r.staging, "");
      const addInfo = resolveAdditionalInfo(empId); // ‚Üê Helper/Replaces
      return [empName, vanName, arriveTime, wave, staging, addInfo];
    });

    // 7) PDF
    const doc = new jsPDF();
    const safeDate = String(date).replace(/[^\w\-]+/g, "_");
    const fileName = `RoutesDetails_${safeDate}.pdf`;

    doc.setFont("helvetica", "bold");
    doc.setFontSize(20);
    doc.text("Routes Details Report", 10, 20);

    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);
    doc.text(`Generated by: ${userName}`, 10, 30);
    doc.text(`Date: ${date}`, 10, 37);

    doc.autoTable({
      startY: 50,
      head: [["Driver", "Vehicle", "Arrival Time", "Wave Time", "Staging", "Additional Info"]],
      body: tableRows,
      styles: { font: "helvetica", fontSize: 9, cellPadding: 3, textColor: [0, 0, 0] },
      headStyles: { fillColor: [0, 25, 51], textColor: [255, 255, 255] }, // bleu #001933
      bodyStyles: { fillColor: [255, 255, 255] },
      alternateRowStyles: { fillColor: [242, 242, 242] },
    });

    // 8) envoi
    const out = doc.output("arraybuffer");
    const tmpPath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tmpPath, Buffer.from(out));

    res.download(tmpPath, fileName, (err) => {
      if (err) {
        console.error("Error sending Routes Details PDF:", err);
        if (!res.headersSent) res.status(500).send("Error downloading PDF.");
      }
      fs.unlink(tmpPath, (unlinkErr) => {
        if (unlinkErr) console.error("Error deleting Routes Details PDF:", unlinkErr);
      });
    });
  } catch (error) {
    console.error("Error generating Routes Details PDF:", error);
    res.status(500).send("Error generating Routes Details PDF.");
  }
});






module.exports = router;
